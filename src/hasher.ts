import type { Data } from "./types.js";
import {
	getDigestHex,
	getUint8Buffer,
	hexStringEqualUint8,
	writeHexToUint8,
} from "./util.js";

interface CreateHasherArgs {
	/**
	 * Hasher WebAssembly instance or module.
	 */
	binary: WebAssembly.Instance | WebAssembly.Module;
	/**
	 * Hash length in bytes.
	 */
	length: number;
	/**
	 * WebAssembly module name
	 */
	name: "argon2" | "bcrypt" | "blake2b" | "scrypt";
	/**
	 * The first 4 bytes of WASM binary SHA1 hash to be used as internal state prefix.
	 */
	prefix: string;
	/**
	 * Initial hasher memory size in bytes.
	 */
	initialMemorySize?: number;
}

interface HasherWasmExports {
	STATE_SIZE: number;
	Hash_Calculate(length: number, bits: number, padding?: number): void;
	Hash_Final(padding?: number): void;
	Hash_GetBuffer(): number;
	Hash_GetState(): number;
	Hash_Init(bits: number): void;
	Hash_SetMemorySize(size: number): number;
	Hash_Update(size: number): number;
	memory: {
		buffer: ArrayBuffer;
	};
}

let MAX_HEAP = 16 * 1024; // 16 KB
let WASM_FUNC_HASH_LENGTH = 4; // SHA1 hash length of WASM binary to be used as internal state prefix.

async function createHasher({
	binary,
	length,
	name,
	prefix,
	initialMemorySize,
}: CreateHasherArgs) {
	let instance =
		binary instanceof WebAssembly.Instance
			? binary
			: await WebAssembly.instantiate(binary);
	let exports = instance.exports as unknown as HasherWasmExports;

	let initialized = false;
	let memory: Uint8Array;

	setMemory(initialMemorySize);

	function get_state_size() {
		let view = new DataView(exports.memory.buffer);
		return view.getUint32(exports.STATE_SIZE, true);
	}

	function is_data_short(data: Data) {
		if (typeof data === "string") {
			/**
			 * Worst case is 4 bytes per unicode character.
			 */
			return data.length <= MAX_HEAP / 4;
		}

		return data.byteLength <= MAX_HEAP;
	}

	function getExports() {
		return exports;
	}

	function getMemory() {
		return memory;
	}

	function setMemory(size?: number) {
		if (size !== undefined) exports.Hash_SetMemorySize(size);

		let offset = exports.Hash_GetBuffer();
		let buffer = exports.memory.buffer;

		memory = new Uint8Array(buffer, offset, size);
	}

	function writeMemory(buffer: Uint8Array, offset?: number) {
		memory.set(buffer, offset);
	}

	function init(bits: number) {
		initialized = true;
		exports.Hash_Init(bits);
	}

	function update(data: Data) {
		if (!initialized) {
			throw new Error("update() called before init().");
		}

		let uint8buffer = getUint8Buffer(data);

		let read = 0;

		while (read < uint8buffer.length) {
			let chunk = uint8buffer.subarray(read, read + MAX_HEAP);
			read += chunk.length;
			memory.set(chunk);
			exports.Hash_Update(chunk.length);
		}
	}

	let digest_chars = Array(length * 2);

	function digest({
		encoding,
		padding,
	}: {
		encoding: "hex" | "binary";
		padding?: number;
	}) {
		if (!initialized) {
			throw new Error("digest() called before init().");
		}

		initialized = false;
		exports.Hash_Final(padding);

		if (encoding === "binary") {
			return memory.slice(0, length);
		}

		return getDigestHex({
			chars: digest_chars,
			input: memory,
			length,
		});
	}

	function save() {
		if (!initialized) {
			throw new Error(
				"save() can only be called after init() and before digest().",
			);
		}

		let state_offset = exports.Hash_GetState();
		let state_length = get_state_size();
		let memory_buffer = exports.memory.buffer;
		let internal_state = new Uint8Array(
			memory_buffer,
			state_offset,
			state_length,
		);

		/**
		 * Prefix is 4 bytes from SHA1 hash of the WASM binary.
		 * It is used to detect incompatible internal states between different versions of hash-wasm
		 */
		let prefixed_state = new Uint8Array(
			WASM_FUNC_HASH_LENGTH + state_length,
		);

		writeHexToUint8({ buffer: prefixed_state, hex: prefix });

		prefixed_state.set(internal_state, WASM_FUNC_HASH_LENGTH);

		return prefixed_state;
	}

	function load(state: Uint8Array) {
		if (!(state instanceof Uint8Array)) {
			throw new Error("load() expects an Uint8Array generated by save()");
		}

		let state_offset = exports.Hash_GetState();
		let state_length = get_state_size();
		let total_length = WASM_FUNC_HASH_LENGTH + state_length;
		let memory_buffer = exports.memory.buffer;

		if (state.length !== total_length) {
			throw new Error(
				`load() expects an Uint8Array generated by save(). Expected ${total_length} bytes, got ${state.length}.`,
			);
		}

		if (
			!hexStringEqualUint8({
				buffer: state.subarray(0, WASM_FUNC_HASH_LENGTH),
				hex: prefix,
			})
		) {
			throw new Error(
				"load() expects an Uint8Array generated by save().",
			);
		}

		let internal_state = state.subarray(WASM_FUNC_HASH_LENGTH);
		new Uint8Array(memory_buffer, state_offset, state_length).set(
			internal_state,
		);
		initialized = true;
	}

	let can_simplify: (data: Data, bits: number) => boolean = is_data_short;

	switch (name) {
		case "argon2":
		case "scrypt":
			can_simplify = () => true;
			break;
		case "blake2b":
			can_simplify = (data, bits) => bits <= 512 && is_data_short(data);
			break;
	}

	function calculate({
		bits,
		data,
		padding,
	}: {
		data: Data;
		bits: number;
		padding?: number;
	}) {
		if (!can_simplify(data, bits)) {
			init(bits);
			update(data);
			return digest({ encoding: "hex", padding });
		}

		let buffer = getUint8Buffer(data);

		memory.set(buffer);

		exports.Hash_Calculate(buffer.length, bits, padding);

		return getDigestHex({ chars: digest_chars, input: memory, length });
	}

	return {
		calculate,
		digest,
		getExports,
		getMemory,
		/**
		 * Hash length in bytes.
		 */
		length,
		init,
		load,
		save,
		setMemory,
		update,
		writeMemory,
	};
}

export { createHasher };
